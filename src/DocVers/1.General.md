<h1 align="center">
    Многопоточность. Основные понятия.
</h1>

###Введение

####Организация материала
Теоретические аспекты, необходимые для выполнения лабораторных работ разделены на 5 частей, читать которые предлагается 
последовательно. Все примеры, связанные с каждой из теоретических частей находятся в соответствующих папках, однако в
тех местах, где они упоминаются, на них предусмотрены ссылки.

В отдельную часть вынесены описания модулей дополнительных элементов многопоточности. Они не являются обязательными для 
освоения курса, но требуются для более глубокого, современного взгляда на использование параллелизма в 
программировании, или помогают писать код проще и короче.

### Модели
По большому счёту, для понимания многопоточности нужно не так уж много, поэтому в начале
будет описан набор сильно упрощённых для понимания моделей, после чего, в процессе рассказа о конкретных аспектах
многопоточности часть из них будет заменяться более подробными описаниями.
####Поток
Чаще всего в ваших программах поток один — тот, точкой входа которого является функция `main()`
И собственно вся задача многопоточности сводится к тому, чтобы выполнять вычисления независимо от потока `main` в других потоках.
Если обобщать, то **поток — это единица _исполнения_ кода**

####Процессор
Для нас представляет собой чёрный ящик, исполняющий код. Для нас не имеет значения, одноядерный наш процессор, или нет.

####Процесс
Контейнер, содержащий в себе контекст исполнения программы (код, данные, привилегии, объекты ОС... В общем, всё то
что необходимо для исполнения программы в рамках операционной системы)
Каждый процесс содержит в себе один или более потоков.

####Операционная система
В контексте многопоточности, для нас важно, что ОС:
1. Создаёт объекты потоков и передаёт их в пользование процессам.
2. Определяет порядок выделения процессорного времени для каждого потока

####Порядок исполнения потоков
Поскольку потоков даже в рамках одного приложения может быть довольно много, возникает вопрос: 
как же они могут исполняться на единственном ядре процессора?

Для этого используется механизм **квантования времени**. Представлять себе это можно как приоритетную очередь, в которую 
выстроены все потоки, существующие в системе. Сверху этой очереди берётся поток и начинается его исполнение на процессоре.
Его исполнение продолжается в течение жестко фиксированного времени, называемого **квантом**. 
После завершения выделенного кванта времени, поток возвращается в приоритетную очередь, а с её верху берётся следующий поток и всё повторяется.

Величина кванта чаще всего связана с определённым числом тактов процессора.

Практическое следствие квантования времени состоит в том, что в процессе разработки приложения невозможно определить, 
в какой момент времени конкретный поток будет вытеснен, или наоборот получит процессорное время.

Причём важно учитывать, что код перед исполнением так или иначе транслируется в набор операций и в конечном итоге, 
исполнение может быть прервано между любыми двумя операциями. То есть, например, выражение `a = (b-c)*(d-b)`
вполне может быть прервано после вычисления первой разности, но до вычисления второй — посреди строчки. 
Хуже того, в теории, сама операция вычитания может быть разделена на несколько и будет выполняться в несколько этапов,
между которыми вполне может быть вытеснен!

####Так чем же в итоге мы будем заниматься?
- Создание и запуск потоков параллельно с main.
- Определение последствий, вызванных порядком исполнения потоков и использование механизмов синхронизации для борьбы с этими последствиями.
- Рассмотрение некоторых общих задач, возникающих при использовании многопоточности и методов решения таких задач.

И следующее, о чём мы поговорим - создание потоков.

[Создание потоков](2.ThreadCreation.md)